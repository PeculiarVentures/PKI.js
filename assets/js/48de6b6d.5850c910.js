"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[363],{76182:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>l,toc:()=>p});var a=n(85893),i=n(11151),s=n(9286);const r='import * as pkijs from \'pkijs\';\nimport * as asn1js from \'asn1js\';\n\nconst crypto = pkijs.getCrypto(true);\n\n// Create certificate\nconst certificate = new pkijs.Certificate();\ncertificate.version = 2;\ncertificate.serialNumber = new asn1js.Integer({ value: 1 });\ncertificate.issuer.typesAndValues.push(new pkijs.AttributeTypeAndValue({\n  type: "2.5.4.3", // Common name\n  value: new asn1js.BmpString({ value: "Test" })\n}));\ncertificate.subject.typesAndValues.push(new pkijs.AttributeTypeAndValue({\n  type: "2.5.4.3", // Common name\n  value: new asn1js.BmpString({ value: "Test" })\n}));\n\ncertificate.notBefore.value = new Date();\nconst notAfter = new Date();\nnotAfter.setUTCFullYear(notAfter.getUTCFullYear() + 1);\ncertificate.notAfter.value = notAfter;\n\ncertificate.extensions = []; // Extensions are not a part of certificate by default, it\'s an optional array\n\n// "BasicConstraints" extension\nconst basicConstr = new pkijs.BasicConstraints({\n  cA: true,\n  pathLenConstraint: 3\n});\ncertificate.extensions.push(new pkijs.Extension({\n  extnID: "2.5.29.19",\n  critical: false,\n  extnValue: basicConstr.toSchema().toBER(false),\n  parsedValue: basicConstr // Parsed value for well-known extensions\n}));\n\n// "KeyUsage" extension\nconst bitArray = new ArrayBuffer(1);\nconst bitView = new Uint8Array(bitArray);\nbitView[0] |= 0x02; // Key usage "cRLSign" flag\nbitView[0] |= 0x04; // Key usage "keyCertSign" flag\nconst keyUsage = new asn1js.BitString({ valueHex: bitArray });\ncertificate.extensions.push(new pkijs.Extension({\n  extnID: "2.5.29.15",\n  critical: false,\n  extnValue: keyUsage.toBER(false),\n  parsedValue: keyUsage // Parsed value for well-known extensions\n}));\n\nconst algorithm = pkijs.getAlgorithmParameters("RSASSA-PKCS1-v1_5", "generateKey");\nif ("hash" in algorithm.algorithm) {\n  algorithm.algorithm.hash.name = "SHA-256";\n}\n\nconst keys = await crypto.generateKey(algorithm.algorithm, true, algorithm.usages);\n\n// Exporting public key into "subjectPublicKeyInfo" value of certificate\nawait certificate.subjectPublicKeyInfo.importKey(keys.publicKey);\n\n// Signing final certificate\nawait certificate.sign(keys.privateKey, "SHA-256");\n\nconst raw = certificate.toSchema().toBER();\n',c={},o="Create and validate certificate",l={id:"examples/certificates-and-revocation/create-and-validate-certificate",title:"Create and validate certificate",description:"In this example, you will see how to create a self-signed X.509 certificate, parse an X.509 certificate, and show how to do certificate chain validation engine.",source:"@site/docs/examples/certificates-and-revocation/create-and-validate-certificate.mdx",sourceDirName:"examples/certificates-and-revocation",slug:"/examples/certificates-and-revocation/create-and-validate-certificate",permalink:"/docs/examples/certificates-and-revocation/create-and-validate-certificate",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"examples",previous:{title:"Certificates and Revocation",permalink:"/docs/examples/certificates-and-revocation/"},next:{title:"Creating and parsing CRLs",permalink:"/docs/examples/certificates-and-revocation/creating-and-parsing-CRLs"}},f={},p=[];function d(e){const t={h1:"h1",p:"p",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"create-and-validate-certificate",children:"Create and validate certificate"}),"\n",(0,a.jsx)(t.p,{children:"In this example, you will see how to create a self-signed X.509 certificate, parse an X.509 certificate, and show how to do certificate chain validation engine."}),"\n",(0,a.jsx)(s.Z,{language:"ts",children:r})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);